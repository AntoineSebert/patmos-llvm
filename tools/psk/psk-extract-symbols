#!/usr/bin/env ruby
#
SYNOPSIS=<<EOF
Extract Symbols from ELF file.
EOF

require File.join(File.dirname(__FILE__),"utils.rb")
include PMLUtils

# Class to extract symbol addresses from an ELF file
class ExtractSymbols
  def initialize(pml)
    @pml,@text_symbols = pml,{}
  end
  def analyze(elf,options)
    IO.popen("patmos-objdump -t '#{elf}'") do |io|
      io.each_line do |line|
        if record = objdump_extract(line)
          next unless options.text_sections.include?(record.section)
          @text_symbols[record.label]=record.address
        end
      end
    end
  end
  def update_pml
    @pml['machine-functions'].each do |mf|
      addr = @text_symbols[get_mbb_label(mf,'0')] || @text_symbols[mf['mapsto']]
      mf_descr = "#{mf['name']}/#{mf['mapsto']}"

      (warn("No symbol for machine function #{mf_descr}");next) unless addr

      mf['blocks'].each do |mbb|
        label = get_mbb_label(mf, mbb)
        if block_addr = @text_symbols[label]
          # Do not emit warning, as it is not possible to estimate block addresses due
          # to subfunctions
          # warn_once("Incorrect address estimation in #{descr}",
          #           "Estimated #{addr}, not #{block_addr}") if addr != @csyms[label]
          addr = block_addr
        end
        mbb['address'] = addr
        (mbb['instructions']||[]).each do |ins|
          ins['address'] = addr
          addr += ins['size']
        end
      end
    end
    @pml
  end
  private
  RE_PATMOS_LABEL = %r{
    (?<address> #{RE_HEX}{8} )
    . {9}
    (?<section> \S+ ) \s+
    (?<value> #{RE_HEX}+ ) \s+
    (?<label> \S+ )
  }x
  def objdump_extract(line)
    return nil unless ks = /\A#{RE_PATMOS_LABEL}$/.match(line)
    record = {}
    [:section,:label].each { |key| record[key] = ks[key] }
    [:address,:value].each { |key| record[key] = Integer(ks[key],16) }
    OpenStruct.new(record)
  end
end

if __FILE__ == $0
  # Standard option parser
  options = OpenStruct.new
  options.text_sections = [".text"]
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} OPTIONS FILE.elf\n" +
      "  Extracts symbols from the given ELF, and adds them to the PML description"
    opts.on("-i", "--input FILE.pml", "Input PML file") { |f| options.input = f }
    opts.on("-o", "--output FILE.pml", "Output PML File") { |f| options.output = f }
    opts.on("", "--text-sections SECTIONS", "CS list of code sections") { |s| options.text_sections = s.split(/\s*,\s*/) }
    opts.on_tail("-h", "--help", "Show this message") { $stderr.puts opts; exit 0 }
  end.parse!
  ($stderr.puts ("Wrong number of positional arguments. Try --help"); exit 1) unless ARGV.length == 1
  ($stderr.puts ("Option --input is mandatory. Try --help"); exit 1) unless options.input

  # input/output
  options.elf = ARGV.first
  pml = File.open(options.input) { |fh| PML.new(fh) }
  extract = ExtractSymbols.new(pml)
  extract.analyze(options.elf,options)
  extract.update_pml.dump_to_file(options.output)
end
