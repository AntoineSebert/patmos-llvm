#!/usr/bin/env ruby
#
SYNOPSIS=<<EOF
Generate flow facts reflecting frequencies from machine-code
execution traces generated with 'pasim --debug'
EOF

require File.join(File.dirname(__FILE__),"utils.rb")
include PMLUtils

# Class to (lazily) read pasim simulator trace
class SimulatorTrace
  def initialize(elf)
    @io = IO.popen("pasim -q --debug 0 --debug-fmt trace -b #{elf} 2>&1 1>/dev/null")
  end
  def close
    @io.close
  end
  def each
    while item=next_item ; yield item ; end
  end
  def next_item
    return nil unless line = @io.gets
    pc,cyc = line.split
    [ Integer(pc,16), Integer(cyc,10) ]
  end
end

class YieldObserver
  def method_missing(msg,*args)
    yield([msg]+args)
  end
end

# Class to monitor trace and generate events
class TraceMonitor
  def initialize(elf,pml,program_start = "main")
    @pml = pml
    @trace = SimulatorTrace.new(elf)
    @start = @pml.mf_mapping_to(program_start)['blocks'].first['address']
    @observers = []
    build_watchpoints
  end
  def subscribe(obj)
    @observers.push(obj)
  end
  def run
    callstack = []
    @trace.each do |pc,cycles|
      @started = true if pc == @start
      next unless @started
      if f = @fpoints[pc]
        publish(:function, f, callstack[-1],cycles)
      end
      if b = @bpoints[pc]
        publish(:block, b, cycles)
      end
      if c = @cpoints[pc]
        callstack.push(c)
      end
      if r = @rpoints[pc]
        if callstack.empty?
          publish(:ret, r, nil, cycles)
          return
        end
        c = callstack.pop
        publish(:ret, r, c, cycles)
      end
    end
  end
  def publish(msg,*args)
    @observers.each do |obs|
      obs.send(msg,*args)
    end
  end
  private
  def build_watchpoints
    @fpoints, @bpoints, @cpoints, @rpoints = {}, {}, {}, {}
    @pml['machine-functions'].each do |mf|
      addr = mf['blocks'].first['address']
      add_watch(@fpoints,addr,FunctionRef.new(mf))
      mf['blocks'].each do |mbb|
        block = BlockRef.new(mf,mbb)
        add_watch(@bpoints,mbb['address'],block)
        if (mbb['successors']||[]).empty?
          rins = InsRef.new(mf,mbb,mbb['instructions'].last)
          add_watch(@rpoints,rins['address'],rins)
        end
        mbb['instructions'].each do |ins|
          instruction = InsRef.new(mf,mbb,ins)
          unless (ins['callees']||[]).empty?
            add_watch(@cpoints,ins['address'],instruction)
          end
        end
      end
    end
  end
  def add_watch(dict,addr,data)
    if ! addr
      warn ("No address for #{data.inspect[0..60]}")
    elsif dict[addr]
      die ("Duplicate function at address #{addr.inspect}")
    else
      dict[addr] = data
    end
  end
end

class GlobalRecorder
  attr_reader :calltarget
  attr_reader :freqs
  def initialize(start_mf)
    @freqs = FrequencyRecord.new
    @calltargets = {}
    @start = start_mf['name']
  end
  def function(callee,callsite,cycles)
    freqs.start(cycles) if callee['name']==@start
    freqs.call(callsite,callee)
  end
  def block(mbb, _)
    freqs.increment(mbb)
  end
  def ret(rsite,csite,cycles)
    freqs.stop(cycles) if(rsite.fref['name']==@start)
  end
end


# Standard option parser
options = OpenStruct.new
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} OPTIONS program.elf\n#{SYNOPSIS}"
  opts.on("-i", "--pml FILE", "Input PML File") { |f| options.input = f }
  opts.on("-o", "--output FILE", "Output PML File") { |f| options.output = f }
  opts.on_tail("-h", "--help", "Show this message") { $stderr.puts opts; exit 0 }
end.parse!

elf = ARGV[0]
die "Wrong number of arguments. Try --help" unless ARGV.length==1
die "Option --pml is mandatory. Try --help" unless options.input

pml = File.open(options.input) { |fh| PML.new(fh) }
tm = TraceMonitor.new(elf,pml)
global = GlobalRecorder.new(pml.mf_mapping_to('main'))
tm.subscribe(global)
tm.run
puts "Global Frequencies"
global.freqs.dump

#outfile = if ! options.output || options.output == "-"
#          then $>
#          else File.new(options.output,"w")
#          end
#outfile.puts YAML::dump(doc)
#outfile.close
