#!/usr/bin/env ruby
#
# Extract flow information from PML file and export as AbsInt AIS file.
#
# TODO: port to python or C++ (to reduce number of languages)

require 'ostruct'
require 'optparse'
require 'yaml'

class String
  def dquote
    '"' + self + '"'
  end
end

# TODO move to some PSK/PML library
# TODO create label depending on architecture?
def get_mbb_label(funcname, blockname)
  ".LBB#{funcname}_#{blockname}"
end

class APXExporter
    attr_reader :outfile
    def initialize(outfile)
	@outfile = outfile
    end

    def export_project(binary, aisfile, results, report, entry)
	# There is probably a better way to do this .. e.g., use a template file.
	@outfile.puts '<!DOCTYPE APX>'
	@outfile.puts '<project xmlns="http://www.absint.com/apx" target="patmos" version="12.10i">'
	@outfile.puts ' <files>'
	@outfile.puts "  <executables>#{binary}</executables>"
	@outfile.puts "  <ais>#{aisfile}</ais>" if aisfile
	@outfile.puts "  <xml_results>#{results}</xml_results>" if results
	@outfile.puts "  <report>#{report}</report>" if report
	@outfile.puts ' </files>'
	@outfile.puts ' <analyses>'
	@outfile.puts '  <analysis enabled="true" type="wcet_analysis" id="aiT">'
	@outfile.puts "   <analysis_start>#{entry}</analysis_start>"
	@outfile.puts '  </analysis>'
	@outfile.puts ' </analyses>'
	@outfile.puts '</project>'
    end
end

class AISExporter
    attr_reader :outfile
    def initialize(outfile)
	@outfile = outfile
    end

    # Generate a global AIS header
    def gen_header(data)
	# TODO get compiler type depending on YAML arch type
	@outfile.puts '#compiler'
	@outfile.puts 'compiler "patmos-llvm";'
	@outfile.puts ''

	#@outfile.puts "#clock rate"
	#@outfile.puts "clock exactly 24 MHz;"
	#@outfile.puts ""

	# TODO any additional header stuff to generate (context, entry, ...)?
    end

    # Export flow facts from a machine-function entry
    def export_function(func)
      func['blocks'].each do |mbb|
        branches = 0
	next unless mbb['instructions']
        mbb['instructions'].each do |ins|
          branches += 1 if ins['branch-type'] && ins['branch-type'] != "none"
          if ins['branch-type'] == 'indirect'
            label = get_mbb_label(func['name'],mbb['name'])
            instr = "#{label.dquote} + #{branches} branches"
	    successors = ins['branch-targets'] ? ins['branch-targets'] : mbb['successors']
            targets = successors.uniq.map { |succ_name|
              get_mbb_label(func['name'],succ_name).dquote
            }.join(", ")
            @outfile.puts "instruction #{instr} branches to #{targets};"
          end
        end
      end
    end

end

# Standard option parser
options = OpenStruct.new
parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} -o file.ais file.pml"
  opts.on("-o", "--output FILE", "Output AIS filename") { |f| options.output = f }
  opts.on("-g", "--header", "Generate AIS header") { |f| options.header = f }
  opts.on("-a", "--apx FILE", "Generate APX file") { |f| options.apx = f }
  opts.on("-b", "--binary FILE", "ELF filename to use for project file") { |f| options.binary = f }
  opts.on("-e", "--entry FUNCTION", "Name of the function to analyse") { |f| options.entry = f }
  opts.on("-r", "--report FILE", "Filename of the report log file") { |f| options.report = f }
  opts.on("-x", "--results FILE", "Filename of the results xml file") { |f| options.results = f }
  opts.on_tail("-h", "--help", "Show this message") { $stderr.puts opts; exit 0 }
end.parse!
if ARGV.length != 1 then $stderr.puts "Wrong number of arguments. Try --help" ; exit 1 ; end

# TODO move this into a common PML library load function
stream = YAML::load_stream((ARGV.first and ARGV.first != "-") ? File.new(ARGV.first) : $<)
if stream.length != 1 then 
  $stderr.puts "Multiple streams not supported, use psk-merge first."
  exit 1
end
data = stream[0]

if options.apx and !options.binary then
  $stderr.puts "Exporting an APX file requires setting a binary filename"
  exit 1
end

# export
outfile = if ! options.output || options.output == "-"
          then $>
          else File.new(options.output,"w")
          end
ais = AISExporter.new(outfile)
ais.gen_header(data) if options.header

data['machine-functions'].each do |func|
  ais.export_function(func)
end
outfile.close

# generate APX file
# TODO make it possible to generate an APX file without actually generating an ais file!
if options.apx 
  apxfile = options.apx == "-" ? $> : File.new(options.apx, "w")
  apx = APXExporter.new(apxfile)

  entry = options.entry ? options.entry : "main"
  apx.export_project(options.binary, options.output, options.results, options.report, entry)
  
  apxfile.close
end
